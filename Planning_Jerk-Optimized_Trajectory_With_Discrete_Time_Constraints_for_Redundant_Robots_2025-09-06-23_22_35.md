

<!-- Meanless: IEEE TRANSACTIONS ON AUTOMATION SCIENCE AND ENGINEERING, VOL. 17, NO. 4, OCTOBER 2020 1711-->

# Planning Jerk-Optimized Trajectory With Discrete Time Constraints for Redundant Robots

Chengkai Dai, Sylvain Lefebvre, Kai-Ming Yu, Jo M. P. Geraedts \( {}^{\circledR } \) , and Charlie C. L. Wang \( {}^{\circledR } \)

Abstract-We present a method for effectively planning the motion trajectory of robots in manufacturing tasks, the tool paths of which are usually complex and have a large number of discrete time constraints as waypoints. Kinematic redundancy also exists in these robotic systems. The jerk of motion is optimized in our trajectory planning method at the meanwhile of fabrication process to improve the quality of fabrication. Our method is based on a sampling strategy and consists of two major parts. After determining an initial path by graph search, a greedy algorithm is adopted to optimize a path by locally applying adaptive filers in the regions with large jerks. The filtered result is obtained by numerical optimization. In order to achieve efficient computation, an adaptive sampling method is developed for learning a collision-indication function that is represented as a support-vector machine. Applications in robot-assisted 3-D printing are given in this article to demonstrate the functionality of our approach.

Note to Practitioners-In robot-assisted manufacturing applications, robotic arms are employed to realize the motion of workpieces (or machining tools) specified as a sequence of waypoints with the positions of tool tip and the tool orientations constrained. The required degree of freedom (DOF) is often less than the robotic hardware system (e.g., a robotic arm has six-DOF). Specifically, rotations of the workpiece around the axis of a tool can be arbitrary (see Fig. 1 for an example). By using this redundancy, i.e., there are many possible poses of a robotic arm to realize a given waypoint, the trajectory of robots can be optimized to consider the performance of motion in velocity, acceleration, and jerk in the joint space. In addition, when fabricating complex models, each tool path can have a large amount of waypoints. It is crucial for a motion planning algorithm to compute a smooth and collision-free trajectory of robot to improve the fabrication quality. The time taken by the planning algorithm should not significantly lengthen the total manufacturing time; ideally, it would remain hidden as computing motions for a layer can be done while the previous layer is printing. The method presented in this article provides an efficient framework to tackle this problem. The framework has been well tested on our robot-assisted additive manufacturing system to demonstrate its effectiveness and can be generally applied to other robot-assisted manufacturing systems.

Index Terms-Discrete time constraints, kinematic redundancy, robotic fabrication, trajectory planning.

## I. INTRODUCTION

ROBOTIC arms are increasingly used as production tools to realize customized manufacturing processes in the applications of Industry 4.0. We focus on cases where a robotic arm is used to produce a physical part from a digital model, following a set of tool paths generated by the process-planning algorithm. The trajectory of motion is often optimized for a robotic manipulator with a kinematic redundancy, e.g., a six-degree-of-freedom (DOF) robotic arm is employed to realize a trajectory with five-DOF constraints (see Fig. 1 for an example in additive manufacturing [1]). Other than additive manufacturing, example processes include robotic machining [2] and automated tape laying for composite fabrication [3].

For these applications, trajectory planning needs to commonly satisfy the following requirements.

1) Discrete Time Constraints: The target trajectories are usually represented as a set of waypoints with given positions and orientations \( {}^{1} \) to be accurately passed through at the tip of tool installed on the robot end-effector. Moreover, speed of the tool is also controlled by assigning a time parameter to each waypoint. Note that the speed for material removal (in subtractive manufacturing [4]) or the speed for material accumulation (in additive manufacturing [5], [6]), called feedrate, is a very important parameter to be controlled in fabrication.

2) Optimized Jerk: The task of tool path with discrete time constraints is mapped into the joint space of a robotic manipulator by its inverse kinematics (IKs). As the time derivative of acceleration in joint space, jerk has great influence on the smoothness of a manipulator's motion. A motion with a smaller jerk has less vibration. To reduce the vibration into a low level is crucial for realizing a high-quality robotic fabrication. An ideal trajectory should have an integral norm of the jerk minimized and the maximal jerk controlled below a reasonable bound.

---

<!-- Footnote -->

Manuscript received September 16, 2019; revised December 1, 2019; accepted February 12, 2020. Date of publication March 5, 2020; date of current version October 6, 2020. This article was recommended for publication by Associate Editor Z. Xiong and Editor K. Saitou upon evaluation of the reviewers' comments. This work was supported in part by the Seed Fund of Industrial Design Engineering Faculty, TU Delft; in part by the Natural Science Foundation of China under Grant 61628211; in part by the CUHK Direct under Grant 4055094; and in part by the Grant from the Research Grants Council of the Hong Kong under Project CUHK/14202219. (Corresponding author: Charlie C. L. Wang.)

Chengkai Dai is with the Department of Design Engineering, Delft University of Technology (TU Delft), 2628 CD Delft, The Netherlands, and also with the Department of Mechanical and Automation Engineering, The Chinese University of Hong Kong (CUHK), Hong Kong.

Sylvain Lefebvre is with Inria, 54600 Nancy, France.

Kai-Ming Yu is with the Department of Industrial and System Engineering, The Hong Kong Polytechnic University, Hong Kong.

Jo M. P. Geraedts is with the Department of Design Engineering, Delft University of Technology (TU Delft), 2628 CD Delft, The Netherlands.

Charlie C. L. Wang is with the Department of Mechanical and Automation Engineering, The Chinese University of Hong Kong (CUHK), Hong Kong (e-mail: cwang@mae.cuhk.edu.hk).

Color versions of one or more of the figures in this article are available online at http://ieeexplore.ieee.org.

Digital Object Identifier 10.1109/TASE.2020.2974771

\( {}^{1} \) Orientation is given as a unit vector so that only five DOFs are constrained.

<!-- Footnote -->

---

<!-- Meanless: 1545-5955 Â© 2020 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See https://www.ieee.org/publications/rights/index.html for more information. Authorized licensed use limited to: TIANJIN UNIVERSITY. Downloaded on November 07,2024 at 06:17:45 UTC from IEEE Xplore. Restrictions apply.-->




<!-- Meanless: 1712 IEEE TRANSACTIONS ON AUTOMATION SCIENCE AND ENGINEERING, VOL. 17, NO. 4, OCTOBER 2020-->

<!-- Media -->

<img src="https://cdn.noedgeai.com/bo_d2slbg77aajc738sf8h0_1.jpg?x=181&y=160&w=704&h=378&r=0"/>

Fig. 1. Example tool path for robot-assisted 3-D printing system [1]; rotation around the red axis can be freely changed because of kinematic redundancy.

<!-- Media -->

3) Collision-Free: Collisions with the surrounding objects and the parts of a model that has already been manufactured must be avoided at all costs along the trajectory of the robot system. While optimizing the jerk, a collision-free property needs to be ensured along the optimized trajectory. This becomes a computational bottleneck when the obstacles have a complex shape. This is unfortunately the case for robotic fabrication as the models to be fabricated usually have complex 3-D freeform surfaces.

Generating a trajectory satisfying the aforementioned requirements is challenging. The tool paths for robotic fabrication can contain a large number of waypoints (typically in the thousands), which are hard to handle with global methods [7]. Online (local) planning methods (see [8], [9]) often include time-jerk optimization strategies to improve the quality of the trajectories. However, they are not applicable to discrete time constraints. A sampling-based framework is proposed in this article to tackle this problem effectively and efficiently.

## A. Problem Statement

Suppose a robotic manipulator with \( L \) DOFs \( \left( {L > 5}\right) \) is employed to follow a user-specified path \( \mathbf{x}\left( t\right)  \in  {\mathbb{R}}^{5} \) with the tool tip held by its end-effector, the location of which is determined by parameters in joint space (i.e., \( \mathbf{q}\left( t\right)  \in  {\mathbb{R}}^{L} \) ) by the forward kinematics as follows:

\[f\left( \mathbf{q}\right)  : \mathbf{q} \in  {\mathbb{R}}^{L} \mapsto  \mathbf{x} \in  {\mathbb{R}}^{5}.\]

Given a collision-indication function \( \Gamma \left( \mathbf{q}\right) \) the sign of which indicates a collision-occurring ("+") or collision-free ("-") configuration, we can define the collision-free configuration space (C-space) as follows:

\[{\mathcal{C}}_{\text{free }} = \left\{  {\mathbf{q} \mid  \Gamma \left( \mathbf{q}\right)  < 0\;\forall \mathbf{q} \in  {\mathbb{R}}^{L}}\right\}  .\]

In robotic fabrication, the problem of finding a feasible jerk-minimized trajectory following the task tool paths is defined as a complex trajectory planning problem with a large size of input (i.e., many waypoints along freeform surfaces as discrete time constraints). Given a set of \( M \) waypoints each at a prescribed time \( {t}_{i} \) with the position of tool tip \( {\mathbf{p}}_{i} \) and the tool orientation \( {\mathbf{n}}_{i} \) ,represented as follows:

\[\mathbf{x}\left( {t}_{i}\right)  = \left( {{\mathbf{p}}_{i},{\widehat{\mathbf{n}}}_{i}}\right) \;\left( {\forall i = 1,\ldots ,M}\right) . \tag{1}\]

We formulate the optimization problem to be solved as follows:

\[\arg \mathop{\min }\limits_{\left\{  {\mathbf{q}}_{i}\right\}  }\mathbb{J} = \mathop{\sum }\limits_{{i = 1}}^{M}{\begin{Vmatrix}\ddot{\mathbf{q}}\left( {t}_{i}\right) \end{Vmatrix}}_{W}^{2}\]

\[\text{s.t.}\mathbf{x}\left( {t}_{i}\right)  = f\left( {\mathbf{q}\left( {t}_{i}\right) }\right) \;\left( {\forall i = 1,\ldots ,M}\right) \]

\[\Gamma \left( {\mathbf{q}\left( {t}_{i}\right) }\right)  < 0\]

\[{\mathbf{q}}_{\min } \leq  \mathbf{q}\left( {t}_{i}\right)  \leq  {\mathbf{q}}_{\max }\]

\[\left| {\dot{\mathbf{q}}\left( {t}_{i}\right) }\right|  \leq  {\mathbf{v}}_{\max },\;\left| {\ddot{\mathbf{q}}\left( {t}_{i}\right) }\right|  \leq  {\mathbf{a}}_{\max },\;\left| {\dddot{\mathbf{q}}\left( {t}_{i}\right) }\right|  \leq  {\mathbf{j}}_{\max }. \tag{2}\]

Here,the measure of jerk is \( \parallel \dddot{\mathbf{q}}{\parallel }_{W}^{2} = {\dddot{\mathbf{q}}}^{T}\mathbf{W}\dddot{\mathbf{q}} \) with \( \mathbf{W} \) being a nonnegative diagonal matrix giving the weights for relative importance between the joints which can also be assigned as equal importance by \( \mathbf{W} = \mathbf{I} \) ,and \( \left| \cdot \right| \) returns a vector with the absolute value of every component. The last four constraints [i.e., the last two lines in (2)] are about joint's position, velocity, acceleration, and jerk, and are defined according to the hardware limits. \( {\widehat{\mathbf{n}}}_{i} \) is a normalized vector so that only five DOFs are constrained. For the sake of compact notation, we denote \( \mathbf{x}\left( {t}_{i}\right) \) and \( \mathbf{q}\left( {t}_{i}\right) \) by \( {\mathbf{x}}_{i} \) and \( {\mathbf{q}}_{i} \) in the rest of this article.

Note that the quality and feasibility of a trajectory are evaluated at discrete time samples in our formulation. We argue that a weak-form solution (i.e., resolution completeness) for the jerk-optimized trajectory planning is obtained when the sampling points are dense enough. Similar strategies have been used and adopted by the robotics community for motion planning [10], [11].

### B.Our Approach

Directly solving the jerk optimization problem along a trajectory with discrete time constraints is time-consuming even if the state-of-the-art method such as [7] is employed. In a relaxed formulation, we propose a greedy algorithm based on local adaptive filtering to the jerk after computing an initial trajectory that minimizes the total velocity variation. We overcome the computational bottleneck of collision detection by a learning-based collision estimator that approximates the continuous decision function:

1) an adaptive greedy algorithm to generate the jerk-optimized trajectory with discrete time constraints (see Section III);

2) an adaptive sampling strategy for effectively learning a collision-indication function (see Section IV).

In summary, we develop a new sampling-based framework for planning the discrete time-constrained trajectory on redundant robots, which can effectively and efficiently generate jerk-optimized trajectories for robotic fabrication.

## II. RELATED WORK

In this section, we review the prior research related to the two major parts of our framework: the trajectory planning approaches considering the task-oriented constraints and the machine-learning-based collision-detection approaches.

<!-- Meanless: Authorized licensed use limited to: TIANJIN UNIVERSITY. Downloaded on November 07,2024 at 06:17:45 UTC from IEEE Xplore. Restrictions apply.-->




<!-- Meanless: DAI et al.: PLANNING JERK-OPTIMIZED TRAJECTORY WITH DISCRETE TIME CONSTRAINTS FOR REDUNDANT ROBOTS 1713-->

## A. Trajectory Planning for Task-Oriented Constrains

Many robot-assisted manufacturing tasks impose constraints on the robot's motion that exhibits kinematic redundancy, where more DOFs are available than the needed DOFs to realize the task. An example is to accumulate materials in 3-D printing by tracing a given path with an axisymmetric filament extruder [1], [12]. In robotic motion planning, there are two types of redundancy, intrinsic and functional ones. Intrinsic redundancy occurs when the dimension of the joint space spanned by a robot's joint variables is greater than the dimension of its operational space, which is the reachable Cartesian space of the end-effector. Functional redundancy is the case where the dimension of the robot's operational space is greater than the dimension of the task space (e.g., the waypoints to be realized).

The intrinsic redundancy problem has been discussed extensively by robotic researchers. Most of the existing methods are playing with the null space of the Jacobian matrix since the Jacobian matrix is nonsquare and exploits the self-motion space of redundant robots [13], [14]. Functional redundancy is different from intrinsic redundancy, in which the Jacobian matrix is nonsingular and square. It is not possible to obtain the null space of the robot itself. Huo and Baron [15] proposed to add an extra column to the Jacobian matrix by introducing a virtual joint. After that, a general solution called twist decomposition algorithm was introduced by using the projection matrices in the operational space to find the null space of Jacobian.

Existing generic trajectory planning methods approach functional redundancy by local [8], [9] or global [16] optimization techniques. The optimization is usually based on different objective metrics such as avoiding obstacles [17], avoiding joint limits [15], avoiding singularities [18], and/or minimizing joint velocities [19], jerks [20], and torques. Some approaches (see [15], [21]) optimize the combination of multiple criteria that are as follows.

1) In local optimization, the strategy is to generate joint configurations [8], [9] that minimize the instantaneous value of the aforementioned metrics. However, these optimization methods only guarantee that a local minima of the objective function is found, which may not be sufficient to ensure path continuity as a whole.

2) Global optimization seeks to generate trajectories that minimize the integral of the performance metric over a prescribed interval, as opposed to just instantaneously in time. However, these approaches are time-consuming because that the geometric algorithm for obstacle avoidance has been included in the loop of computation (see [7], [21]). The optimizations also suffer from the initial guess problem, i.e., whether solutions can be found highly relies on the initial guess. Thus, existing global approaches cannot guarantee an algorithmic completeness (some inputs may not lead to solutions).

Differently, our approach is sampling-based and can ensure algorithmic completeness.

In the area of motion planning, sampling-based algorithms are the most successful method because of their efficiency and completeness [22], [23]. To deal with the redundancy, researchers define constraints as manifolds and efficiently sample the manifolds by forcing the constraints via rejection sampling and projection sampling of the C-space [24], [25]. However, such algorithms cannot handle the tracking problem with a predefined path. This article is partially similar to a new global graph-search method [26], where the self-motion space is parameterized by angular and path distances and a graph is constructed by cell-decomposition applied to these two parameters. The trajectory planning problem is solved by the shortest path search on the graph. However, the method can be very slow when a dense sampling is applied. In addition, it is unclear how to optimize for minimal jerkiness by such a graph-search-based method.

## B. Machine-Learning-Based Collision Detection

When performing the trajectory planning in the configuration space, the solutions falling in the subspace of collision-occurring configurations should be abandoned. For realizing the collision avoidance, the collision-free C-space should be computed and represented in an appropriate way. As discussed in [27], geometry-based methods are usually limited to low-dimensional C-spaces, due to the combinatorial complexity involved in computing the boundary of the collision-free space for high-dimensional configurations. Moreover, for computing the optimal trajectory in a numerical optimization framework, the collision-free C-space is desired to be presented (or approximated) by an algebraic function [i.e., \( \Gamma \left( \cdot \right) \) as discussed above in (2)].

To solve this problem, machine-learning techniques have been used for collision detection to approximate collision-free spaces based on sampled configurations. For example, Pan et al. [28] conducted the incremental support vector machines (SVMs) to learn a representation of C-space in an online step. Their method samples the C-space by iteratively exploiting the near boundary configurations. Das et al. [29] developed a kernel-based perceptron learning algorithm, which can efficiently update the classifier actively. This enables the function to online update the decision boundary of a classifier. Gaussian mixture models (GMMs) are used in [30] to represent the collision-aware C-space, from which the collision detection is performed by assigning a query configuration with the same label as the closest Gaussian. Pan and Manocha [31] adopt a \( k \) -nearest neighbor ( \( \mathrm{k} \) -NN) model in their sampling-based motion planners, which can significantly reduce the time required for collision checking. Neural networks have also been applied to perform collision checking (see [32]); however, the training step could be time-consuming when multiple layers need to be trained in a neural network. Recently, Salehian et al. [33] develop an exhaustive sampling method to find a collision-decision function, which can be treated as collision constraints in the optimization-based computation of IKs. Although potentially applicable after certain modifications, none of the above approaches have considered the specific situation in robot-assisted manufacturing, where the shape of obstacles (specifically the workpiece to work on) is changing with time. For instance in additive manufacturing, the part being created is making the space of collision-free configurations increasingly complex. In this article, we develop a sophisticate method to tackle this manufacturing-oriented situation, which can use a very small number of training samples to provide an accurate function for efficiently estimating the collision-indication function in the numerical optimization framework.

<!-- Meanless: Authorized licensed use limited to: TIANJIN UNIVERSITY. Downloaded on November 07,2024 at 06:17:45 UTC from IEEE Xplore. Restrictions apply.-->




<!-- Meanless: 1714 IEEE TRANSACTIONS ON AUTOMATION SCIENCE AND ENGINEERING, VOL. 17, NO. 4, OCTOBER 2020-->

## III. TRAJECTORY PLANNING

Given a set of waypoints as discrete time constraints for robotic fabrication, our trajectory planning algorithm computes the configurations of manipulators as a sequence of optimized configurations \( \mathcal{Q} = \left\{  {\mathbf{q}}_{i}\right\}  \left( {i = 1,\ldots ,M}\right) \) in two steps. First, a trajectory is determined by a graph-search method that minimizes the total cost of joint transition, i.e., the initial values of \( {\mathbf{q}}_{i}\mathrm{\;s} \) are assigned. In the second step,a greedy algorithm is developed to optimize the trajectory by locally applying adaptive filters to adjust the value of \( {\mathbf{q}}_{i} \) s in regions with large jerks. A validation mechanism is developed to ensure that the resultant trajectory is completely collision-free at the waypoints.

## A. Initialization

We employ a sampling-based method to determine a feasible trajectory. When the sampling rate is dense enough, it provides a very good solution for determining an initial trajectory to be further optimized.

Since only position and orientation are defined on a way-point, the tool is allowed to rotate freely around the tool-axis orientation \( {\widehat{\mathbf{n}}}_{i} \) . Therefore,this leads to infinite possibilities to define a pose in the robotic manipulator's C-space, which results in kinematic redundancy. The rotation can be defined by a quaternion as a rotational angle \( \theta \) around the vector \( {\widehat{\mathbf{n}}}_{i} \) , that is

\[{\mathbf{h}}_{i} = \left( {{\widehat{\mathbf{n}}}_{i}\sin \left( \frac{\theta }{2}\right) ,\cos \left( \frac{\theta }{2}\right) }\right) \;\left( {\forall \theta  \in  \left\lbrack  {-\pi ,\pi }\right\rbrack  }\right) . \tag{3}\]

We first sample the task space at every waypoint by using different values of \( \theta \) and then employ a graph-search approach to find a feasible path by connecting the selected samples-one from each waypoint.

A graph \( \mathcal{G} \) spanning the task space of a given path \( \mathcal{X} = \left\{  {\mathbf{x}}_{i}\right\} \) is constructed by the following method (see also Fig. 2 for an illustration).

1) Nodes: Each waypoint \( {\mathbf{x}}_{i} = \left( {{\mathbf{p}}_{i},{\widehat{\mathbf{n}}}_{i}}\right) \) is first uniformly sampled into \( n \) rotational angles for \( \theta  \in  \left\lbrack  {-\pi ,\pi }\right\rbrack \) to determine \( n \) quaternions by (3). This leads to \( n \) points in the special Euclidean group \( \mathbb{{SE}}\left( 3\right) \) . For each point in \( \mathbb{{SE}}\left( 3\right) \) ,multiple kinematic solutions in the joint space can be determined by IKs. Without loss of generality, we assume that \( {N}_{i} \) points \( \left( {{N}_{i} > n}\right) \) in the joint space can be obtained for realizing a waypoint \( {\mathbf{x}}_{i} - \) denoted by \( {\mathbf{q}}_{i,j} \) \( \left( {j = 1,\ldots ,{N}_{i}}\right) \) . They are defined as a ladder of nodes, \( {\mathcal{G}}_{i} = \left\{  {\mathbf{q}}_{i,j}\right\} \) ,in \( \mathcal{G} \) . Each ladder of nodes is displayed as a column of nodes in Fig. 2. Nodes corresponding to a configuration with collision are excluded from the graph, which can be efficiently checked by a collision-detection library (see [34]).

<!-- Media -->

<!-- figureText: \( {\mathrm{x}}_{1} \) \( {x}_{2} \) \( {\mathrm{X}}_{3} \) \( {\mathrm{X}}_{\mathrm{n} - 1} \) -q \( {\mathrm{q}}_{\mathrm{n},1} \) \( {\mathrm{q}}_{\mathrm{n} - 1,2} \) \( {\mathrm{q}}_{\mathrm{n},2} \) \( {\mathrm{q}}_{\mathrm{n} - 1,3} \) \( {\mathrm{q}}_{\mathrm{n},\mathrm{k}} \) \( {\mathrm{q}}_{\mathrm{n} - 1,\mathrm{j}} \) \( {\mathrm{q}}_{1,1} \) \( {q}_{2} \) \( {\mathrm{q}}_{3,1} \) \( {\mathrm{q}}_{1,2} \) \( {q}_{2,3} \) \( {\mathrm{q}}_{3,3} \) \( {q}_{2,k} \) \( {\mathrm{q}}_{3,\mathrm{k}} \) \( {\mathrm{q}}_{2,1} \) -->

<img src="https://cdn.noedgeai.com/bo_d2slbg77aajc738sf8h0_3.jpg?x=923&y=173&w=737&h=568&r=0"/>

Fig. 2. Illustration for the graph used in our approach to find an initial trajectory. Nodes in the same column (called ladder) represent different feasible solutions in the joint space for realizing the same waypoint. Edges are added between nodes in neighboring ladders. The shortest path on the graph is highlighted by the blue dashed lines.

<!-- Media -->

2) Edges: Directed edges are constructed by linking nodes in a ladder \( {\mathcal{G}}_{i} \) to nodes in the next ladder \( {\mathcal{G}}_{i + 1} \) while respecting the joint velocity limits. The edge between \( {\mathbf{q}}_{i,j} \) and \( {\mathbf{q}}_{i + 1,k} \) is only added when

\[\frac{{\mathbf{q}}_{i + 1,k} - {\mathbf{q}}_{i,j}}{{t}_{i + 1} - {t}_{i}} \leq  {\mathbf{v}}_{\max }. \tag{4}\]

To avoid the "winding effect" caused by revolute joints, we evaluate the circular distance between configurations here and also the rest of this article. The following transition cost is added as the weight of an edge (angular-velocity estimation):

\[w\left( {{\mathbf{q}}_{i,j},{\mathbf{q}}_{i + 1,k}}\right)  = {\left( {\mathbf{q}}_{i + 1,k} - {\mathbf{q}}_{i,j}\right) }^{T}\mathbf{W}\left( {{\mathbf{q}}_{i + 1,k} - {\mathbf{q}}_{i,j}}\right)  \tag{5}\]

with \( \mathbf{W} \) being the nonnegative diagonal matrix that gives the weights of relative importance between the joints.

A shortest path on \( \mathcal{G} \) from a start node \( {\mathbf{q}}_{s} \in  {\mathcal{G}}_{1} \) to an end node \( {\mathbf{q}}_{e} \in  {\mathcal{G}}_{M} \) actually defines a trajectory \( \mathcal{Q} \) that minimizes the total cost of transition as follows:

\[{\mathbb{J}}_{\text{trans }} = \mathop{\sum }\limits_{{i = 1}}^{{M - 1}}{\begin{Vmatrix}{\mathbf{q}}_{i + 1} - {\mathbf{q}}_{i}\end{Vmatrix}}_{W}^{2}. \tag{6}\]

The shortest path \( \mathcal{P} \) on \( \mathcal{G} \) can be found by applying the Dijkstra's algorithm for multiple sources-using all nodes in \( {\mathcal{G}}_{1} \) as the sources. After updating costs on all nodes in \( \mathcal{G} \) , the shortest path can be traced back from a node in \( {\mathcal{G}}_{M} \) having the smallest cost. We start from the sampling rate at \( n = 4 \) . If no path can be found on \( \mathcal{G} \) ,we double the value of \( n \) to generate a graph with denser nodes and search the path again.

The shortest path that minimizes the total cost of transition \( {\mathbb{J}}_{\text{trans }} \) does not directly lead to an optimized path with a minimum jerk. However, it provides a good initial path to be further optimized. This algorithm for obtaining an initial trajectory is resolution complete. It means that the algorithm in finite time either finds a solution if one exists or correctly reports the failure. The failure case happens when there exists no path satisfying the velocity limit \( {\mathbf{v}}_{\max } \) .

<!-- Meanless: Authorized licensed use limited to: TIANJIN UNIVERSITY. Downloaded on November 07,2024 at 06:17:45 UTC from IEEE Xplore. Restrictions apply.-->




<!-- Meanless: DAI et al.: PLANNING JERK-OPTIMIZED TRAJECTORY WITH DISCRETE TIME CONSTRAINTS FOR REDUNDANT ROBOTS 1715-->

## B. Improvement by Local Filtering

With a given sequence of configurations \( \mathcal{Q} \) in joint space according to the waypoints in \( \mathcal{X} \) ,the jerks of trajectory at these discrete time points can be evaluated by the method of local approximation-the formulation will be given below. In general, the trajectory determined by computing the shortest path on the graph \( \mathcal{G} \) in the initialization step may also lead to jerky motion as the initial path does not directly minimize the total jerk [i.e., \( \mathbb{J} \) in (2)]. To reduce the total jerk on a trajectory with a large number of waypoints, we develop an algorithm to improve the trajectory in an iterative routine after obtaining an initial trajectory by the graph-search method presented above.

Our algorithm is based on a greedy strategy. The pseudocode of our algorithm is given in Algorithm 1. At each iteration,we choose a trajectory point \( {\mathbf{q}}_{c} \) with the maximum jerk among all points as \( c = \arg \mathop{\max }\limits_{i}\left\{  {\begin{Vmatrix}{\ddot{\mathbf{q}}}_{i}\end{Vmatrix}}_{W}\right\} \) . A local path \( \widetilde{\mathcal{P}} \) is extracted with \( {\mathbf{q}}_{c} \) as the center by using a margin \( d \) (i.e., \( \widetilde{\mathcal{P}} = \left\{  {{\mathbf{q}}_{a},\ldots ,{\mathbf{q}}_{b}}\right\} \) with \( b,a = c \pm  d \) ). We apply the local filtering to optimize the local path \( \widetilde{\mathcal{P}} \) at the jerk level by solving the total-jerk problem defined on this local region [as \( {\mathbb{J}}_{\text{local }} \) in (12)]. The following algorithm is developed to further enhance the capability in jerk optimization.

1) Window-Size Adaptation: When no feasible solution is found,i.e.,the value of \( {\mathbb{J}}_{\text{local }} \) cannot be reduced,it means that the computation of optimization is stuck at a local minimum. Then, we enlarge the window size of filtering by including more trajectory points until it reaches a user-specified bound.

2) Locking Mechanism: A locking mechanism is developed in our algorithm to further enhance its capability to overcome the local optimum. Specifically, when the window size of a local path has reached its maximally allowed bound, we will mark all the points in this path as locked. The locked points will not be included in the further selection of points with a maximal jerk (i.e., the center of local path extraction). A point will be unlocked; if it has been covered by some other local paths, the locally defined total jerk of which can be reduced.

The adaptive local filtering with the locking mechanism is repeatedly applied to regions with maximal jerk until the trajectory meets the required jerk limit \( {\mathbf{j}}_{\max } \) or the maximum number of iterations is reached (which, however, rarely occurs in our experiments). Note that the requirement on the maximal jerk is achieved by the algorithm instead of the numerical optimization conducted during the local filtering.

Details for evaluating derivatives at waypoints and computing local filter at the jerk level are presented as follows.

1) Derivatives at Waypoints: To compute the derivatives of \( \mathbf{q} \) ,we construct local curves interpolating the waypoints.

<!-- Media -->

Algorithm 1 Jerk Optimization by Local Filtering

---

	Input: An initial joint trajectory \( \mathcal{P} \) .
	Output: An optimized trajectory \( \mathcal{P} \) .
	Set all points in \( \mathcal{P} \) as free;
- Find a point \( {\mathbf{q}}_{c} \) with a maximal jerk on \( \mathcal{P} \) ;
while \( \left| {\ddot{\mathbf{q}}}_{c}\right|  > {\mathbf{j}}_{\max } \) AND not enough iterations do
		Build a local path \( \widetilde{\mathcal{P}} \) centered at \( {\mathbf{q}}_{c} \) with margin \( d \) ;
		success = false;
		while success \( \neq \) true AND \( d \leq  {d}_{\max } \) do
			success \( = \) Minimize \( \left( {{\mathbb{J}}_{\text{local }}\left( \widetilde{\mathcal{P}}\right) }\right) \) ;
			if success then
				Mark all points in \( \widetilde{\mathcal{P}} \) as free;
			else
				Expand \( \widetilde{\mathcal{P}} \) centered at \( {\mathbf{q}}_{c} \) by \( d = d + 5 \) ;
		if success \( \neq \) true then
			Mark all points in \( \widetilde{\mathcal{P}} \) as locked;
		Find \( {\mathbf{q}}_{c} \) with a maximal jerk only among the free
		points on \( \mathcal{P} \) ;
15 return \( \mathcal{P} \) ;

---

<!-- Media -->

Specifically, we have

\[{\mathbf{q}}_{i}\left( t\right)  = \mathop{\sum }\limits_{{j =  - 2}}^{2}{B}_{j}\left( t\right) {\mathbf{q}}_{i + j} \tag{7}\]

with the basis functions \( {B}_{j}\left( t\right) \) determined by imposing the interpolation constraints: \( {\mathbf{q}}_{i}\left( {t}_{i + j}\right)  = {\mathbf{q}}_{i + j}\left( {\forall j =  - 2,\ldots , + 2}\right) \) . This results in

\[{B}_{j}\left( t\right)  = \mathop{\sum }\limits_{{k = 0}}^{4}{b}_{k,j + 2}{t}^{k} \tag{8}\]

where \( {b}_{k,j + 2} = {\beta }_{k + 1,j + 3} \) with

\[{\left\lbrack  {\beta }_{a,b}\right\rbrack  }_{5 \times  5} = \left\lbrack  \begin{matrix} 1 & {t}_{i - 2} & {t}_{i - 2}^{2} & \ldots & {t}_{i - 2}^{4} \\  1 & {t}_{i - 1} & {t}_{i - 1}^{2} & \ldots & {t}_{i - 1}^{4} \\  \vdots & \vdots & \vdots &  \ddots  & \vdots \\  1 & {t}_{i + 2} & {t}_{i + 2}^{2} & \ldots & {t}_{i + 2}^{4} \end{matrix}\right\rbrack   \tag{9}\]

As a result, \( \dddot{\mathbf{q}}\left( {t}_{i}\right) \) can be approximated as follows:

\[\dddot{\mathbf{q}}\left( {t}_{i}\right)  = \mathop{\sum }\limits_{{j =  - 2}}^{2}{\dddot{B}}_{j}\left( {t}_{i}\right) {\mathbf{q}}_{i + j}. \tag{10}\]

When having a constant time interval \( h = {t}_{i + 1} - {t}_{i} \) between all waypoints and letting \( {t}_{i} = 0 \) ,we will have a very compact formula in this special case

\[\dddot{\mathbf{q}}\left( {t}_{i}\right)  = \frac{{\mathbf{q}}_{i + 2} - 2{\mathbf{q}}_{i + 1} + 2{\mathbf{q}}_{i - 1} - {\mathbf{q}}_{i - 2}}{2{h}^{3}}. \tag{11}\]

This is in fact the central finite-difference formula for the third-order numerical derivative obtained by applying the Taylor expansion.

<!-- Meanless: Authorized licensed use limited to: TIANJIN UNIVERSITY. Downloaded on November 07,2024 at 06:17:45 UTC from IEEE Xplore. Restrictions apply.-->




<!-- Meanless: 1716 IEEE TRANSACTIONS ON AUTOMATION SCIENCE AND ENGINEERING, VOL. 17, NO. 4, OCTOBER 2020-->

<!-- Media -->

<!-- figureText: 20.0 Joint_1 Joint_5 Joint_2 Joint_3 Max_jerk Joint_4 1.0 0.5 46 46 30 40 17.5 15.0 12.5 10.0 7.5 5.0 2.5 1.0 0.0 10 20 -->

<img src="https://cdn.noedgeai.com/bo_d2slbg77aajc738sf8h0_5.jpg?x=146&y=164&w=724&h=537&r=0"/>

Fig. 3. Change of the maximum jerk at each joint during the iterations of our method. The maximal jerk has been reduced by \( {83.6}\%  - {95.8}\% \) on all the six joints. The dashed line shows the allowed maximal jerk as \( {j}_{\max } = {1.0} \) in this example.

<!-- Media -->

2) Filter at the Jerk Level: Our filter is applied to a sequence of joint configurations as \( \left\{  {{\mathbf{q}}_{a},{\mathbf{q}}_{a + 1},\ldots ,{\mathbf{q}}_{b}}\right\} \) to minimize the jerk while still satisfying the discrete time constraints at \( \left\{  {{\mathbf{x}}_{a},{\mathbf{x}}_{a + 1},\ldots ,{\mathbf{x}}_{b}}\right\} \) . We formulate the filter as a local optimization problem to minimize the sum of jerks at the waypoints

\[\mathop{\min }\limits_{\left\{  {\mathbf{q}}_{a},\ldots ,{\mathbf{q}}_{b}\right\}  }{\mathbb{J}}_{\text{local }} = \mathop{\sum }\limits_{{i = a}}^{b}{\begin{Vmatrix}\dddot{\mathbf{q}}\left( {t}_{i}\right) \end{Vmatrix}}_{W}^{2}\]

\[\text{s.t.}\mathbf{x}\left( {t}_{i}\right)  = f\left( {\mathbf{q}\left( {t}_{i}\right) }\right) \;\left( {\forall i = a,\ldots ,b}\right) \]

\[\Gamma \left( {\mathbf{q}\left( {t}_{i}\right) }\right)  < 0\]

\[{\mathbf{q}}_{\min } \leq  \mathbf{q}\left( {t}_{i}\right)  \leq  {\mathbf{q}}_{\max }\]

\[\left| {\dot{\mathbf{q}}\left( {t}_{i}\right) }\right|  \leq  {\mathbf{v}}_{\max },\left| {\ddot{\mathbf{q}}\left( {t}_{i}\right) }\right|  \leq  {\mathbf{a}}_{\max }. \tag{12}\]

The optimization problem defined in (12) is a nonconvex problem with nonlinear constraints. Therefore, we use the sequential quadratic programming (SQP) to solve it. When evaluating \( {\ddot{\mathbf{q}}}_{a} \) and \( {\ddot{\mathbf{q}}}_{b} \) ,those waypoints located at the margin (i.e., \( {\ddot{\mathbf{q}}}_{a - 2},{\ddot{\mathbf{q}}}_{a - 1},{\ddot{\mathbf{q}}}_{b + 1} \) ,and \( {\ddot{\mathbf{q}}}_{b + 2} \) ) are involved as constants instead of variables. Therefore, when applying this local filter to different regions of the path \( \mathcal{P} \) ,we should reserve a margin with at least four points between the regions that will be locally updated. Note that we do not impose the requirement of maximally allowed jerk \( {\mathbf{j}}_{\max } \) in this local filter as it is considered at the algorithm level.

The maximally allowed number of iterations in our greedy algorithm is set as 100 in the implementation. Other parameters are set as \( d = 5 \) and \( {d}_{\max } = {20} \) according to our experiments. As shown in Figs. 3 and 4, our algorithm for trajectory optimization can effectively and efficiently reduce both the total jerk \( \mathbb{J} \) and the maximal jerk on initial trajectories determined by the graph search.

## C. Collision-Free Verification

After computing an optimized path \( \mathcal{P} \) ,we need to verify the collision-free at every configuration on the path. This is implemented by applying an advanced collision-detection library (e.g.,the FCL library [34]) at every point \( {\mathbf{q}}_{i} \in  \mathcal{P} \) .

<!-- Media -->

<!-- figureText: 35000 30 40 30000 25000 20000 15000 5000 0 0 10 20 -->

<img src="https://cdn.noedgeai.com/bo_d2slbg77aajc738sf8h0_5.jpg?x=921&y=161&w=724&h=540&r=0"/>

Fig. 4. Total sum of squared jerks, \( \mathbb{J} \) in (2),on the trajectory is effectively reduced during the iterations of our method. The value has been reduced by \( {99.4}\% \) on the final result.

<!-- Media -->

If the collision is found at \( {\mathbf{q}}_{d} \) ,we adopt the following projection method to correct it:

1) resampling the rotational angle \( \theta \) around the corresponding waypoint \( {\mathbf{x}}_{d} \) in a very dense rate (i.e.,with the step of \( \pi /{500} \) );

2) computing the collision-free IK solutions \( \left\{  {\widehat{\mathbf{q}}}_{d}^{k}\right\} \) for these dense samples;

3) selecting the closest one to serve as a projected solution as follows:

\[{\mathbf{q}}_{d} = \arg \mathop{\min }\limits_{\left\{  {\widehat{\mathbf{q}}}_{d}^{k}\right\}  }{\begin{Vmatrix}{\mathbf{q}}_{d} - {\widehat{\mathbf{q}}}_{d}^{k}\end{Vmatrix}}_{\infty }. \tag{13}\]

The infinity norm is employed here to control the maximal variation for all joints. The result of the projection may still violate the requirement of a maximal jerk. Fortunately, our approximation of \( \Gamma \) is accurate (see Section IV),and we did not observe such a scenario in our experiments. In the worse case, we can still split one trajectory into two short trajectories to avoid large jerk in motion.

## IV. LEARNING-BASED COLLISION ESTIMATION

An efficient method for estimating the collision-indication function \( \Gamma \left( \cdot \right) \) is needed for solving the jerk-minimization problem by numerical optimization. Collision checking is a computational bottleneck for motion planning. For the general shape of obstacles, there is no trivial mapping from the working space to the C-space. For the sake of efficiency, we develop a sampling-based approach to learn a function \( \widetilde{\Gamma }\left( \cdot \right) \) to accurately approximate the collision-indication function \( \Gamma \left( \cdot \right) \) . Without loss of generality,collision detection can be formulated as a binary classification problem with \( \widetilde{\Gamma }\left( \cdot \right)  < 0 \) for collision-free and \( \widetilde{\Gamma }\left( \cdot \right)  \geq  0 \) for collided configurations. This section first introduces our machine-learning method for the representation of \( \widetilde{\Gamma }\left( \cdot \right) \) and then introduces our contact-centered sampling strategy used to reduce the required number of training samples.

<!-- Meanless: Authorized licensed use limited to: TIANJIN UNIVERSITY. Downloaded on November 07,2024 at 06:17:45 UTC from IEEE Xplore. Restrictions apply.-->




<!-- Meanless: DAI et al.: PLANNING JERK-OPTIMIZED TRAJECTORY WITH DISCRETE TIME CONSTRAINTS FOR REDUNDANT ROBOTS 1717-->

## A. Approximate Representation of Collision Function

Kernel-based function representations such as SVMs and neural networks can be used to generate an algebraic function for \( \widetilde{\Gamma }\left( \cdot \right) \) . In this article,we choose SVM as: 1) learning of SVM is a convex optimization problem that can be efficiently solved and 2) SVMs yield sparser models for high-dimensional nonlinear classification problems, i.e., with the less number of kernel functions so that the value of \( \widetilde{\Gamma }\left( \cdot \right) \) can be evaluated more efficiently.

Briefly, an SVM algorithm learns a hypothesis function, which maps data from an input space to the feature space. Here,the input space is the C-space \( \{ \mathbf{q}\} \) and the feature space is the status of collision. Given \( n \) sample points with labels obtained by the geometry-based collision detection library, we can learn a radial basis function (RBF)-based representation of \( \widetilde{\Gamma }\left( \cdot \right) \) as follows:

\[\widetilde{\Gamma }\left( \mathbf{q}\right)  = \mathop{\sum }\limits_{{i = 1}}^{N}{\alpha }_{i}K\left( {{\mathbf{q}}_{i},\mathbf{q}}\right)  + b \tag{14}\]

by using the Gaussian kernel function

\[K\left( {{\mathbf{q}}_{i},\mathbf{q}}\right)  = \exp \left( {-\gamma {\begin{Vmatrix}\mathbf{q} - {\mathbf{q}}_{i}\end{Vmatrix}}^{2}}\right) .\]

The learning result is the centers of kernels \( \left\{  {\mathbf{q}}_{i}\right\} \) as the subset of training samples,the coefficients of RBFs \( \left\{  {\alpha }_{i}\right\} \) ,and the value of a bias term \( b \) . As an algebraic function is provided here,we can evaluate the gradient of \( \widetilde{\Gamma }\left( \mathbf{q}\right)  \approx  \Gamma \left( \mathbf{q}\right) \) by the method presented in [33] when solving the problem defined in (12).

By the property of sparsity in the SVM learning, the number of kernels \( N \) could be much less than the number of training samples \( n \) . It is desirable to obtain fewer kernels,so that \( \widetilde{\Gamma }\left( \cdot \right) \) can then be evaluated more efficiently. \( \gamma \) is a parameter specifying the narrowness of the Gaussian,and we use \( \gamma  = {0.7} \) in all our tests. Details of SVM learning and the method for tuning the parameter \( \gamma \) can be found in [35] and [36]. Note that,to make the collision-indication provided by \( \widetilde{\Gamma }\left( \cdot \right) \) more conservative,we update the value of the bias term \( b \) to \( b = b + \epsilon \) after obtaining the solution of SVM learning as \( \widetilde{\Gamma }\left( \cdot \right) .\epsilon  = {1.0} \) is employed in our implementation.

In the applications of robot-assisted manufacturing, the collision-indication function needs to be evaluated and also trained efficiently. The efficient evaluation is demanded as the function is used in the loop of the numerical optimization. The efficient training is also very important as the shape of a workpiece under fabrication (also considered as obstacles) is changed from time to time. By using the routine developed in [1] for additive manufacturing, the collision-indication function needs to be updated when the fabrication process moves from one working surface (WS) layer to the next one. A similar concept of WS layers can also be found in the subtractive manufacturing [37]. In general, we need to train a function \( \widetilde{\Gamma }\left( \cdot \right) \) for each WS when conducting the robot-assisted manufacturing. To reduce the training time, an effective way is to use less number of training samples. We develop a special sampling strategy for this purpose below. Our method can construct the training data set, which is more capable to identify the boundary between collided and collision-free regions in the C-space.

## B. Sampling Strategy for Training

Inspired by the active-learning method with a coarse-to-fine iterative sampling refinement strategy presented in [28], we first generate sparse samples in the C-space to capture the large-scale topology of the indication function. This function is later refined by adding more selected samples near the decision boundary.

1) C-Space of Contact: To generate more effective training samples, we introduce a concept of contact C-space as a set of all configurations, where the robotic system's tool touches a WS \( \mathcal{S} \) . Given a forward kinematic function \( \mathbf{f}\left( \cdot \right) \) of the robotic system,the contact C-space of the WS \( \mathcal{S} \) is defined as follows:

\[{\mathcal{Q}}_{\text{cont }} = \left\{  {\mathbf{q} \mid  \operatorname{dist}\left( {\mathbf{f}\left( \mathbf{q}\right) ,\mathcal{S}}\right)  = 0\;\forall \mathbf{q} \in  {\mathbb{R}}^{L}}\right\}  \]

with dist \( \left( \cdots \right) \) being the distance function.

Samples are generated around \( {\mathcal{Q}}_{\text{cont }} \) by the steps of initialization and the contact-centered refinement as presented below. A projection operator \( \Upsilon \left( \cdot \right) \) is developed to project a general configuration \( \mathbf{q} \) onto the C-space of contact by solving the following minimization problem as follows:

\[\Upsilon \left( \mathbf{q}\right)  = \arg \mathop{\min }\limits_{{\mathbf{q}}^{ * }}{\begin{Vmatrix}{\mathbf{q}}^{ * } - \mathbf{q}\end{Vmatrix}}_{2}^{2}\]

\[\text{s.t.}\operatorname{dist}\left( {\mathbf{f}\left( {\mathbf{q}}^{ * }\right) ,\mathcal{S}}\right)  = 0\text{.} \tag{15}\]

In our implementation,the solution of \( {\mathbf{q}}^{ * } \) is computed by the SQP, and the distance function is efficiently evaluated by the proximity query package (PQP) library [38].

2) Initial Sampling: Sparse samples in \( {\mathcal{Q}}_{\text{cont }} \) are initially generated by sampling the WS \( \mathcal{S} \) . Specifically,we randomly sample \( m \) points on \( \mathcal{S} \) . At each sample point,we can generate a quaternion by using the surface normal and a random angle \( \theta \) as mentioned in (3). The corresponding configuration of each quaternion can be obtained by the IK calculation, and the collision status is obtained by the geometry-based collision detection (e.g., the flexible collision library (FCL) presented in [34]). This gives the initial set of training samples-all from the C-space of contact.

3) Up-Scaling and Refinement: Two steps are employed to generate more samples in the nearby region around the the contact C-space \( {\mathcal{Q}}_{\text{cont }} \) .

1) Up-Scaling: The purpose of this step is to generate nearly uniform samples in the nearby region of \( {\mathcal{Q}}_{\text{cont }} \) for capturing the topological structure of the collision-indication function \( \Gamma \left( \cdot \right) \) . Randomly sampling the WS will not enable this uniformity in the configuration space as the mapping of IK can be very complicated. Directly generating random samples in the C-space would, however, require much more samples to capture the structure: most of the samples generated in this way would be far away from the C-space of contact, \( {\mathcal{Q}}_{\text{cont }} \) . Differently, we generate more samples near the C-space of contact by up-sampling the initial set of samples. When the distance between an existing sample and any of its \( \mathrm{k} \) -NNs is larger than a threshold \( {\tau }_{\alpha } \) ,a new sample is generated in the middle. In effect, \( {50}\% \) of the newly generated samples will be projected onto the C-space of contact, \( {\mathcal{Q}}_{\text{cont }} \) . The up-scaling is repeated until no new sample can be generated under the density control of \( {\tau }_{\alpha } \) (e.g., \( {\tau }_{\alpha } = {0.8} \) is chosen in our implementation by empirical tests).

<!-- Meanless: Authorized licensed use limited to: TIANJIN UNIVERSITY. Downloaded on November 07,2024 at 06:17:45 UTC from IEEE Xplore. Restrictions apply.-->




<!-- Meanless: 1718 IEEE TRANSACTIONS ON AUTOMATION SCIENCE AND ENGINEERING, VOL. 17, NO. 4, OCTOBER 2020-->

<!-- Media -->

Algorithm 2 Generate Samples for Training

---

Input: A working surface \( S \) .
Output: A resultant set \( \mathcal{Q} \) of samples.
/* The step of Initialization
Randomly generate \( m \) samples for \( \mathcal{Q} \) with all on \( {\mathcal{Q}}_{\text{cont }} \) ;
repeat
	/* The step of Up-scaling */
	foreach \( \mathbf{q} \in  \mathcal{Q} \) do
		if \( \mathbf{q} \in  {\mathcal{Q}}_{\text{cont }} \) then
			Search the \( k \) -NN of \( \mathbf{q} \) as a set \( {\mathcal{Q}}_{NN} \) ;
			foreach \( {\mathbf{q}}^{ * } \in  {\mathcal{Q}}_{NN} \) do
				if \( \begin{Vmatrix}{{\mathbf{q}}^{ * } - \mathbf{q}}\end{Vmatrix} > {\tau }_{\alpha } \) then
					GenerateNewSample \( \left( {\mathbf{q},{\mathbf{q}}^{ * },\mathcal{Q}}\right) \) ;
	/* The step of Refinement */
	foreach \( \mathbf{q} \in  \mathcal{Q} \) do
		if \( \mathbf{q} \in  {\mathcal{Q}}_{\text{cont }} \) then
			Search the \( k \) -NN of \( \mathbf{q} \) as a set \( {\mathcal{Q}}_{NN} \) ;
			for every \( {\mathbf{q}}^{ * } \in  {\mathcal{Q}}_{NN} \) do
				if \( \begin{Vmatrix}{{\mathbf{q}}^{ * } - \mathbf{q}}\end{Vmatrix} > {\tau }_{\beta } \) AND \( L\left( {\mathbf{q}}^{ * }\right)  \neq  L\left( \mathbf{q}\right) \) then
					/* \( L\left( \cdot \right) \) returns the collision
							status */
					GenerateNewSample \( \left( {\mathbf{q},{\mathbf{q}}^{ * },\mathcal{Q}}\right) \) ;
tuntil no new point can be added into \( \mathcal{Q} \) ;
return \( Q \) ;
Procedure GenerateNewSample \( \left( {\mathbf{q},{\mathbf{q}}^{ * },\mathcal{Q}}\right) \)
begin
	\( {\mathbf{q}}_{\text{new }} = \frac{1}{2}\left( {\mathbf{q} + {\mathbf{q}}^{ * }}\right) ; \)
	/* 50% new samples projected */
	Generate a random \( \rho  \in  \lbrack 0,1) \) ;
	if \( \rho  \geq  {0.5} \) then \( {\mathbf{q}}_{\text{new }} = \Upsilon \left( {\mathbf{q}}_{\text{new }}\right) \) Add \( {\mathbf{q}}_{\text{new }} \) into \( \mathcal{Q} \) ;
End Procedure

---

<!-- Media -->

2) Refinement: After up-scaling, a step of boundary-aware refinement is applied to generate samples for learning a more precise decision boundary when approximating the collision-indication function \( \Gamma \left( \cdot \right) \) . Similarly,this is based on searching the k-NNs of existing samples. When a sample and its neighbor have different collision labels, we generate a new sample if their distance is larger than a threshold \( {\tau }_{\beta } \) . A denser sampling is desired along the boundary; therefore, \( {\tau }_{\beta } < {\tau }_{\alpha } \) is used (e.g., \( {\tau }_{\beta } = {0.05} \) in our implementation). Again, the 50% of the newly generated samples will be projected onto \( {\mathcal{Q}}_{\text{cont }} \) ,and the refinement is repeatedly applied until no new sample can be generated under the density control of \( {\tau }_{\beta } \) . These two steps are repeatedly applied until the specified total number of samples has been generated. For the nearest-neighbor search, \( k = {20} \) is used in all our examples. The pseudocode of these two steps can be found in Algorithm 2. As can be found in Section IV-C of analysis, the approximation function generated by SVM can better capture the indication function with the help of a much smaller number of training samples.

<!-- Media -->

<!-- figureText: 13 ~ 1 40 -->

<img src="https://cdn.noedgeai.com/bo_d2slbg77aajc738sf8h0_7.jpg?x=929&y=167&w=719&h=398&r=0"/>

Fig. 5. Three-DOF planar robotic arm for tracing a 2-D path (green) with obstacles (red). The example is used to study the effectiveness of our sampling strategy for learning the collision-indication function. As shown in the right, the C-space of contact \( {\mathcal{Q}}_{\text{cont }} \) is displayed by blue for the collision-free region (i.e., \( {\mathcal{Q}}_{\text{cont }} \cap  {\mathcal{Q}}_{\text{free }} \) ) and gray for the collided region (i.e., \( {\mathcal{Q}}_{\text{cont }} \cap  {\mathcal{Q}}_{\text{free }} \) ). Note that the white regions in the C-space are not reachable by the robotic arm.

<!-- Media -->

## C. Analysis

We employ a three-DOF planar redundant robotic arm as an example to analyze the effectiveness of our sampling strategy in a 2-D path tracing setup (see the left of Fig. 5). To follow the 2-D path displayed in green, the three joints of this robot form a C-space of contact in the C-space (see the right of Fig. 5). When presenting obstacles as the red objects, the blue regions denote the collision-free configurations on the C-space of contact. In this analysis, we study how our sampling-and-learning method can effectively capture the boundary between collision-free and collided regions.

Fig. 6 shows our results comparing to those of SVM learning by random samples. The ground-truth collision-indication function on the C-space of contact is shown in Fig. 6(a). The progressive results of our sample generation algorithm are given in Fig. 6(b), from which it is easy to find that samples generated by our method properly capture the boundary of the indication function after the steps of up-scaling and refinement. As can be seen in Fig. 6(c), the structure and the boundary of collision-free regions cannot be captured when the same number of samples are generated randomly. In this case, less effective kernels are obtained by SVM learning. The region of collision-free configurations can be better captured when using more random samples-see the result shown in Fig. 6(d), where the same number of effective kernels is obtained by SVM learning. However, the function learned in this case is still less accurate than ours. In summary, the sampling strategy developed in our algorithm can better capture the boundary of a collision-indication function when SVM learning is adopted. More experiments about the prediction rate and the checking time will be shown in Section V.

<!-- Meanless: Authorized licensed use limited to: TIANJIN UNIVERSITY. Downloaded on November 07,2024 at 06:17:45 UTC from IEEE Xplore. Restrictions apply.-->




<!-- Meanless: DAI et al.: PLANNING JERK-OPTIMIZED TRAJECTORY WITH DISCRETE TIME CONSTRAINTS FOR REDUNDANT ROBOTS 1719-->

<!-- Media -->

<!-- figureText: (a) (b) (c) (d) -->

<img src="https://cdn.noedgeai.com/bo_d2slbg77aajc738sf8h0_8.jpg?x=141&y=159&w=1509&h=283&r=0"/>

Fig. 6. (a) Comparisons to demonstrate the effectiveness by using the samples generated by our method to learn a function \( \widetilde{\Gamma }\left( \cdot \right) \) to approximate the collision-indication function \( \Gamma \left( \cdot \right) \) . From the left to right in (b),the progressive sampling results and their corresponding \( \bar{\Gamma }\left( \cdot \right) \) obtained by SVM are shown as: 1) after the first round of up-scaling (with \( n = {474} \) and \( N = {348} \) ); 2) after the first round of refinement (with \( n = {1527} \) and \( N = {714} \) ); and 3) the final result of sample generation (with \( n = {1698} \) and \( N = {779} \) ) after a few iterations. The learning results are worse than those of ours if random sampling is employed to generate the (c) same number of samples as ours and the (d) same number of kernels as ours, where (c) 1698 samples only can result in 517 effective kernels and (d) 2553 samples need to obtain 779 effective kernels.

<!-- figureText: X Axis Y Axis Z Axis -->

<img src="https://cdn.noedgeai.com/bo_d2slbg77aajc738sf8h0_8.jpg?x=138&y=671&w=743&h=410&r=0"/>

Fig. 7. Hardware setup of our robot-assisted 3-D printing system with six DOFs. Left: UR3 robot-arm-based setup with a fixed material-extruder for better material adhesion. Right: with the help of the relationship between the extruder frame \( E \) and the frame of workpiece \( O \) ; an analytic IK solver can be employed to obtain configurations in the joint space from a quaternion determined by rotating the frame \( E \) around the orientation given in a waypoint.

<!-- Media -->

## V. EXPERIMENTAL RESULTS

We implement our algorithm on the robot operating system (ROS) framework with our UR3-based robotic fabrication setup by using \( \mathrm{C} +  + \) . All evaluations are executed on a PC with Intel Core i7 processor, 32-GB RAM, and GeForce GTX 2070 video card, running Ubuntu 16.04 (Xenial, 64-bit OS). Besides of computational experiments, the performance of our approach has been demonstrated on two different hardware systems for robot-assisted 3-D printing (i.e., Fig. 7 for a six-DOF system and Fig. 8 for a eight-DOF system).

Our planning algorithm can effectively and efficiently compute a smooth and collision-free trajectory of the redundant robot. The quality of fabrication can be significantly improved as the jerk has been optimized on the motion trajectories. More details can be found in the reported experimental tests below.

## A. Learning Results of Collision-Indication Functions

In our implementation, the libSVM library [39] was used for SVM learning. The effectiveness of our sample generation method for SVM-learning-based estimation of collision-indication function has been demonstrated by a planar redundant robot in Section IV-C. Here, we further study its performance in the robot-assisted fabrication by using 3-D tool paths. To quantitatively measure the accuracy of \( \widetilde{\Gamma }\left( \cdot \right) \) for approximating \( \Gamma \left( \cdot \right) \) ,we evaluate the following true-negative-ratio (TNR) metric based on samples of verification:

\[\mathrm{{TNR}} = \frac{\mathrm{{TN}}}{\mathrm{{TN}} + \mathrm{{FP}}} \tag{16}\]

<!-- Media -->

<!-- figureText: ã -->

<img src="https://cdn.noedgeai.com/bo_d2slbg77aajc738sf8h0_8.jpg?x=916&y=673&w=743&h=503&r=0"/>

Fig. 8. Hardware setup of the robot-assisted 3-D printing system with eight DOFs consisting of a six-DOF ABB IRB1200-7/0.7 robotic arm and a two-DOF IRBP A-250 tilting table.

<!-- Media -->

where true negative (TN) denotes the number of samples with \( \widetilde{\Gamma }\left( \cdot \right)  < 0 \) that are really collision-free,while the false positive (FP) gives the number of samples with \( \widetilde{\Gamma }\left( \cdot \right)  \geq  0 \) that, however, will not lead to collision or contact. TNR provides the percentage of samples that are truly collision-free among all samples with the negative value returned by the indication function \( \widetilde{\Gamma }\left( \cdot \right) \) ,the larger the better.

We generate two different types of samples to verify the accuracy of a classifier on different WSs, as shown in Fig. 9. In the first type, verification samples are generated at the nearby regions of the contact manifold to simulate the situations while computing the numerical optimization. In the second type, verification samples are generated on the contact manifold by the method of initial samples presented in Section IV-B. In both types of tests, 100000 verification samples are employed for all examples. The true status of the samples is generated by the geometry-based collision-detection library. The resultant statistics can be found in Table I. It is easy to find that the accuracy of our collision-indication function is much higher than the classifier generated by SVM learning from random samples. Note that, for conducting a fair comparison, we also provide the results of a random-sampling-based classifier with the same number of kernels (i.e.,the same value of \( N \) ),which needs much more samples. The nearby sets of verification samples are more similar to the situation that happens during numerical optimization. Comparing to the geometry computation-based collision-detection technique (e.g., FCL library [34]), the evaluation of \( \Gamma \left( \cdot \right) \) with \( N = {887} \) kernels is \( 5 \times \) faster if only collision check is needed. However, the gradient of the collision-indication function needs to be evaluated in the numerical optimization [i.e., (12)]. To provide a similar function by the geometry-based collision detection, we need to evaluate the distance to obstacles. In this case, our method is around \( {220} \times \) faster.

<!-- Meanless: Authorized licensed use limited to: TIANJIN UNIVERSITY. Downloaded on November 07,2024 at 06:17:45 UTC from IEEE Xplore. Restrictions apply.-->




<!-- Meanless: 1720 IEEE TRANSACTIONS ON AUTOMATION SCIENCE AND ENGINEERING, VOL. 17, NO. 4, OCTOBER 2020-->

<!-- Media -->

<img src="https://cdn.noedgeai.com/bo_d2slbg77aajc738sf8h0_9.jpg?x=141&y=164&w=744&h=405&r=0"/>

Fig. 9. Two WSs with tool paths used in our experimental tests. (a) One WS layer of the armadillo model with 2545 waypoints-its resultant trajectory is shown in Fig. 10. (b) WS layer of the armadillo model with 4681 waypoints having the optimized trajectory given in Fig. 11.

TABLE I

STATISTICS FOR THE ACCURACY OF COLLISION-INDICATION FUNCTIONS GENERATED BY SVM LEARNING

<table><tr><td>Verification Type</td><td colspan="2">Nearby Region</td><td colspan="2">C-space of Contact</td></tr><tr><td>TNR</td><td>WS1 Fig.9(a)</td><td>WS2 Fig.9(b)</td><td>WS1 Fig.9(a)</td><td>WS2 Fig.9(b)</td></tr><tr><td>Our Method ( \( n = {3020} \) & \( N = {887} \) )</td><td>0.963</td><td>0.944</td><td>0.969</td><td>0.956</td></tr><tr><td>By Random Samples \( \left( {n = {3020}\text{ & }N = {479}}\right) \)</td><td>0.894</td><td>0.876</td><td>0.942</td><td>0.923</td></tr><tr><td>By Random Samples \( \left( {n = {5842}\text{ & }N = {887}}\right) \)</td><td>0.889</td><td>0.883</td><td>0.951</td><td>0.943</td></tr></table>

<!-- Media -->

## B. Results of Jerk-Optimized Trajectories

In this section, we show the resultant motion trajectories generated by our jerk-optimized planning method. The first example is a tool path as shown in Fig. 9(a) for the six-DOF robotic system. The progressive results for optimizing the trajectory have been shown in Figs. 3 and 4. It can be observed that our optimization approach can reduce both the maximal jerk and the total sum of a squared jerk by \( {83.6}\%  - {95.8}\% \) and \( {99.4}\% \) ,respectively. Fig. 10 shows the path's angular values on all six joints before and after the optimization, where the zoomed-in views clearly show the improvement on smoothness. In the second example, the tool path as shown in Fig. 9(b) is the target to be realized on the UR3-robot-based hardware platform for 3-D printing. The trajectories in the joint space before and after optimization are given in Fig. 11, where the maximal jerk on all joints have been reduced by up to \( {95}\% \) .

We also compare the results generated by our method to the graph-search-based method with a denser sampling, i.e., the nodes in a ladder are generated by every degree for the value of \( \theta \) in (3). This is actually the method used in [1]. Detailed computational statistics of our trajectory planning algorithm in the robot-assisted 3-D printing application can be found in Table II. It can be observed that our method generates a trajectory with much lower jerks (both the maximal jerk and the total jerks) while being \( {10} \times \) faster. This demonstrates both the effectiveness and the efficiency of our approach.

## C. Robot-Assisted 3-D Printing

We also test the trajectories computed by our method in physical experiments using the robot-assisted 3-D printing. To explicitly show the quality improvement in the real fabrication process, we choose an example tool path for additive manufacturing on a planar layer as a specimen. The specimen are fabricated on the eight-DOF system (see Fig. 8), where the change of the maximum jerk at each joint during the iteration is shown at the top row of Fig. 12. The bottom row of Fig. 12 gives the results of 3-D printing by a graph-search-based path (left) and the jerk-optimized path (right). Unwanted blobs can be clearly observed on the path with large jerks, while the jerk-optimized path leads to much smoother material deposition. For the sake of a better illustration, planar tool paths are conducted in this experiment to demonstrate the influence of large jerk in additive manufacturing. The dynamic difference between the trajectories before and after optimization can be more clearly observed in the supplementary video at https://youtu.be/e8ISmh9MPrE.In summary, the improvement of both the motion smoothness and the quality of fabrication that can be generated by our jerk-optimized trajectory planning algorithm is very significant.

The total time required by our trajectory planning approach is much shorter than the total time of 3-D printing, which is a significant improvement compared to earlier work presented in [1]. On average,a \( {20} \times \) speedup is achieved. For instance, the armadillo model shown in Fig. 1 contains more than 300 curved layers and more than 50 layers totaling \( {2000} + \) waypoints. The original algorithm presented in [1] needs about \( {40}\mathrm{\;h} \) for motion planning. With the help of the new algorithm presented in this article, the total time for planning has been reduced to only \( 2\mathrm{\;h} \) . For a tool path with 2545 waypoints, the computation can be completed in 116.43 s,which is much shorter than the fabrication time for the curved layer of this path,i.e.,around \( {460}\mathrm{\;s} \) . Motion planning is no longer a bottleneck for robot-assisted fabrication as we can compute the trajectory of the next layer while working on the current one.

<!-- Meanless: Authorized licensed use limited to: TIANJIN UNIVERSITY. Downloaded on November 07,2024 at 06:17:45 UTC from IEEE Xplore. Restrictions apply.-->




<!-- Meanless: DAI et al.: PLANNING JERK-OPTIMIZED TRAJECTORY WITH DISCRETE TIME CONSTRAINTS FOR REDUNDANT ROBOTS 1721-->

<!-- Media -->

<!-- figureText: 1.0 Joint 1 Joint 2 Joint 3 3.0 2.5 2.0 1.5 0.5 1.9 0.0 1.8 -0.5 1.7 -1.0 1.6 1.5 1500 2000 2500 500 1000 1500 2000 2500 Joint 5 Joint 6 1.5 -1.3 1.0 -1.4 0.5 -1.5 -1.6 -0.5 -1.0 -1.5 - 2.0 - 2.5 1500 2000 2500 0 500 1000 1500 2000 2500 1.5 Initial from graph search 0.5 Our result 1.0 -1.3 0.0 0.5 -1.4 -0.5 0.0 -1.5 â0.5 -1.6 -1.5 -1.0 -0.3 -2.0 -1.5 -0.4 -2.5 - 2.0 -0.5 -3.0 -2.5 -0.6 -3.5 -3.0 500 1000 1500 2000 2500 500 1000 Joint 4 1.0 3.0 0.5 -2.8 2.5 0.0 - 2.9 2.0 - 3.0 1.5 - 3.1 1.0 -1.5 0.5 1.9 -2.0 0.0 1.8 - 2.5 -0.5 1.7 - 3.0 -1.0 1.6 500 1000 1500 2000 2500 500 1000 -->

<img src="https://cdn.noedgeai.com/bo_d2slbg77aajc738sf8h0_10.jpg?x=140&y=173&w=1513&h=1004&r=0"/>

Fig. 10. Comparison between the initial trajectory from the graph-based search and after applying local refinement for each joint on the six-DOF system. The zoomed-in views clearly show the smoothness improvement after the local refinement. The tool path is as shown in Fig. 9(a).

<!-- figureText: joint. 1 joint 2 4 Joint 5 joint 6 3000 4000 4000 Initial from graph search 1.5 1.0 joint 4 3.5 3.0 2.5 1.0 0.5 1000 2000 3000 4000 2000 -->

<img src="https://cdn.noedgeai.com/bo_d2slbg77aajc738sf8h0_10.jpg?x=140&y=1299&w=740&h=498&r=0"/>

Fig. 11. Comparison of jerk (the absolute value) between the initial trajectory from the graph-based search (displayed in blue) and after applying the local refinement for each joint (displayed in orange), where significant improvements can be easily observed. Again, this is implemented on the six-DOF system, and the tool path is as shown in Fig. 9(b).

<!-- Media -->

## D. Limitations

Our method is an approach based on local processing, so that a more optimal solution can be found by global methods [e.g., the TrajOpt approach [7])]. When working on a tool path with 60 waypoints (the first 60 points of WS1), the resultant trajectory with a smaller total sum of squared jerks \( \left( {\mathbb{J} = {1.64}}\right) \) can be obtained from this TrajOpt method optimizing the whole path together. The result of our method is \( \mathbb{J} = {7.27} \) . However,the major merit of our approach is its capability to handle a path with a large number of waypoints, which is hard to be processed by existing methods. When applying the TrajOpt approach to a tool path with many waypoints (e.g., the whole WS1), the optimizer is terminated by reaching the penalty iteration limit-it means that the optimization is in fact unsuccessful. The best motion generated by TrajOpt is not well optimized (see Fig. 13 for a comparison with our approach).

<!-- Media -->

TABLE II

STATISTICS OF COMPUTATION

Example Our Method Dense Graph

Wpt. Computing Time (sec.) J* Time J*

Path Num. Init. Optm. Total Eq.(2) (sec.) Eq.(2)

WS1 2,545 86 30 116 0.232 1,837 1.34

WS2 4, 681 265 58 322 0.697 3, 283 3.82

<table><tr><td rowspan="2"/><td rowspan="2">Joint</td><td colspan="2">Maximal Jerk on Path</td><td rowspan="2">Resultant Maximal Jerk</td></tr><tr><td>Before Optm.</td><td>After Optm.</td></tr><tr><td rowspan="6">WS1</td><td>1</td><td>15.16</td><td>0.76</td><td>1.85</td></tr><tr><td>2</td><td>5.13</td><td>0.80</td><td>1.09</td></tr><tr><td>3</td><td>5.92</td><td>0.97</td><td>1.75</td></tr><tr><td>4</td><td>6.32</td><td>0.97</td><td>1.35</td></tr><tr><td>5</td><td>21.87</td><td>0.94</td><td>2.24</td></tr><tr><td>6</td><td>17.72</td><td>0.74</td><td>5.26</td></tr><tr><td rowspan="6">WS2</td><td>1</td><td>8.43</td><td>0.77</td><td>2.23</td></tr><tr><td>2</td><td>2.39</td><td>0.42</td><td>2.55</td></tr><tr><td>3</td><td>9.83</td><td>0.97</td><td>4.18</td></tr><tr><td>4</td><td>8.22</td><td>0.89</td><td>1.58</td></tr><tr><td>5</td><td>3.55</td><td>0.71</td><td>1.98</td></tr><tr><td>6</td><td>15.59</td><td>0.78</td><td>3.25</td></tr></table>

*The value of \( \mathbb{J} \) is reported at the unit of \( \times  {10}^{3} \) .

<!-- Meanless: Authorized licensed use limited to: TIANJIN UNIVERSITY. Downloaded on November 07,2024 at 06:17:45 UTC from IEEE Xplore. Restrictions apply.-->




<!-- Meanless: 1722 IEEE TRANSACTIONS ON AUTOMATION SCIENCE AND ENGINEERING, VOL. 17, NO. 4, OCTOBER 2020-->

<!-- figureText: 16 A250/Joint_1 Joint_4 A250/Joint_2 Joint_1 Joint_6 Joint_2 Max_jerk Joint_3 1.0 0.5 0.0 60 80 14 12 10 1.0 0 20 40 -->

<img src="https://cdn.noedgeai.com/bo_d2slbg77aajc738sf8h0_11.jpg?x=148&y=166&w=732&h=927&r=0"/>

Fig. 12. Experimental test conducted on a robotic system with eight DOFs (see Fig. 8). Top: progressive results of jerk optimization can effectively reduce the maximal jerk on all the eight joints to be less than a threshold 1.0. Bottom: results of fabrication by a path with (left) large jerk from the graph search and (right) jerk-optimized path. Unwanted blobs can be observed on the result generated by a path with large jerk as the material deposition is not smooth.

<!-- figureText: joint 1 Joint 2 joint 3 0.0 2500 1500 2000 Joint 5 - 500 Our method -1.0 -2.0 -3.0 500 1000 2500 1.0 0.5 -1.0 -1.5 -->

<img src="https://cdn.noedgeai.com/bo_d2slbg77aajc738sf8h0_11.jpg?x=142&y=1336&w=736&h=497&r=0"/>

Fig. 13. When applying the TrajOpt approach [7] to the whole tool path WS1, their best result is much worse than that of ours-see the joint angles shown here.

<img src="https://cdn.noedgeai.com/bo_d2slbg77aajc738sf8h0_11.jpg?x=912&y=177&w=736&h=825&r=0"/>

Fig. 14. Robustness tests conducted on the eight-DOF setup. Left column: total sum of squared jerks, \( \mathbb{J} \) in (2). Right column: change of the maximum jerk at each joint during the iterations of our method. From top to bottom: with different noise levels within \( {5}^{ \circ  },{10}^{ \circ  } \) ,and \( {15}^{ \circ  } \) .

<!-- Media -->

It is also interesting to study the robustness of our approach by adding noises to the orientations of waypoints. Specifically, each orientation can be mapped to a point on the Gaussian sphere,and random noises are added within a range of \( {5}^{ \circ  },{10}^{ \circ  } \) , and \( {15}^{ \circ  } \) ,respectively,in three tests taken on the eight-DOF system. The performance of our approach on noisy input is given in Fig. 14. The maximum jerk cannot meet the constraint as less than 1.0 although the overall jerk \( \mathbb{J} \) can always be reduced significantly. This is considered as the major limitation of our approach.

## VI. Conclusion and Discussion

We have presented a novel sampling-based framework for planning discrete time-constrained trajectories on redundant robots. The major technical contributions include: 1) a local filter for jerk minimization while considering other hardware-oriented constraints for feasibility; 2) a greedy algorithm to be applied to a path with many waypoints; and 3) an adaptive sampling strategy for effectively learning a collision-indication function with high accuracy. With the help of these techniques, our approach can efficiently minimize the total jerk and reduce the maximal jerk. Our motion planning solution is \( {40} \times \) faster than the method in [1] when being applied to all tool paths of the Armadillo model-the model shown in Fig. 1.

We have tested the performance of the jerk-minimized trajectory in the application of robot-assisted 3-D printing using a setup with one robotic arm and one tilting table. The results of our experiment tests are very encouraging, where the fabrication quality in terms of smoothness has been clearly improved while the time efficiency is ensured. However, the experiments are still conducted on hardware systems with relatively low DOF (i.e., \( L \leq  8 \) ). The scalability of our algorithm on higher DOF needs to be further investigated. Another limitation of our method is that the collision-indication function obtained by learning assumes a very certain environment. It will be interesting to see how it can be further developed for a dynamic environment, e.g., human-robot interaction. For future development, we will investigate the relationship between motion smoothness and layer height/path width in additive manufacturing. Moreover, we also plan to test this approach of the jerk-optimized trajectory planning in the applications of machining (i.e., subtractive manufacturing).

<!-- Meanless: Authorized licensed use limited to: TIANJIN UNIVERSITY. Downloaded on November 07,2024 at 06:17:45 UTC from IEEE Xplore. Restrictions apply.-->




<!-- Meanless: DAI et al.: PLANNING JERK-OPTIMIZED TRAJECTORY WITH DISCRETE TIME CONSTRAINTS FOR REDUNDANT ROBOTS 1723-->

## ACKNOWLEDGMENT

The authors would like to thank the help offered by T. Zhang, X. Chen, and A. Mok during the physical experiments of this article. REFERENCES

[1] C. Dai, C. C. L. Wang, C. Wu, S. Lefebvre, G. Fang, and Y.-J. Liu, "Support-free volume printing by multi-axis motion," ACM Trans. Graph., vol. 37, no. 4, pp. 1-14, Jul. 2018, doi: 10.1145/ 3197517.3201342.

[2] Y. N. Hu and Y. H. Chen, "Implementation of a robot system for sculptured surface cutting. Part 2. Finish machining," Int. J. Adv. Manuf. Technol., vol. 15, no. 9, pp. 630-639, Aug. 1999.

[3] G. Marsh, "Automating aerospace composites production with fibre placement," Reinforced Plastics, vol. 55, no. 3, pp. 32-37, 2011, doi: 10. 1016/S0034-3617(11)70075-3.

[4] K.-C. Chan and C. C. L. Wang, "Progressive segmentation for MRR-based feed-rate optimization in CNC machining," in Proc. IEEE Int. Conf. Autom. Sci. Eng. (CASE), Aug. 2015, pp. 691-696.

[5] J. Etienne et al., "CurviSlicer: Slightly curved slicing for 3-axis printers," ACM Trans. Graph., vol. 38, no. 4, pp. 81:1-81:11, Jul. 2019.

[6] M. Ibrahim, N. Isa, D. N. Saude, and M. Ibrahim, "Verification of feed rate effects on filament extrusion for freeform fabrication," J. Eng. Appl. Sci., vol. 11, pp. 6556-6561, May 2016.

[7] J. Schulman et al., "Motion planning with sequential convex optimization and convex collision checking," Int. J. Robot. Res., vol. 33, no. 9, pp. 1251-1270, Aug. 2014, doi: 10.1177/0278364914528132.

[8] D. P. Martin, J. Baillieul, and J. M. Hollerbach, "Resolution of kinematic redundancy using optimization techniques," IEEE Trans. Robot. Autom., vol. 5, no. 4, pp. 529-533, 1989.

[9] B. Siciliano, "Kinematic control of redundant robot manipulators: A tutorial," J. Intell. Robotic Syst., vol. 3, no. 3, pp. 201-212, 1990, doi: 10.1007/BF00126069.

[10] P. Cheng and S. M. LaValle, "Resolution complete rapidly-exploring random trees," in Proc. IEEE Int. Conf. Robot. Autom., vol. 1, May 2002, pp. 267-272.

[11] S. Karaman and E. Frazzoli, "Sampling-based algorithms for optimal motion planning," Int. J. Robot. Res., vol. 30, no. 7, pp. 846-894, Jun. 2011.

[12] C. Wu, C. Dai, G. Fang, Y.-J. Liu, and C. C. L. Wang, "General support-effective decomposition for multi-directional 3-D printing," IEEE Trans. Autom. Sci. Eng., to be published.

[13] Y. Nakamura, Advanced Robotics: Redundancy and Optimization, 1st ed. Boston, MA, USA: Addison-Wesley, 1990.

[14] T. Yoshikawa, "Basic optimization methods of redundant manipulators," Lab. Robot. Autom., vol. 8, no. 1, pp. 49-60, 1996.

[15] L. Huo and L. Baron, "The joint-limits and singularity avoidance in robotic welding," Ind. Robot, Int. J., vol. 35, no. 5, pp. 456-464, Aug. 2008.

[16] S. Seereeram and J. T. Wen, "A global approach to path planning for redundant manipulators," in Proc. IEEE Int. Conf. Robot. Autom., vol. 2, May 1993, pp. 283-288.

[17] S. E. Khadem and R. V. Dubey, "A global Cartesian space obstacle avoidance scheme for redundant manipulators," Optim. Control Appl. Methods, vol. 12, no. 4, pp. 279-286, Oct. 1991.

[18] J. LÃ©ger and J. Angeles, "Off-line programming of six-axis robots for optimum five-dimensional tasks," Mechanism Mach. Theory, vol. 100, pp. 155-169, Jun. 2016. [Online]. Available: http://www.sciencedirect.com/science/article/pii/S0094114X16000264

[19] R. Dubey and J. Y. S. Luh, "Redundant robot control using task based performance measures," J. Robotic Syst., vol. 5, no. 5, pp. 409-432, Oct. 1988. [Online]. Available: https://onlinelibrary.wiley.com/doi/abs/10.1002/rob.4620050502

[20] P. Freeman, "Minimum jerk trajectory planning for trajectory constrained redundant robots," Ph.D. dissertation, Dept. Elect. Syst. Eng., Washington Univ. St. Louis, St. Louis, MO, USA, 2012.

[21] Z. Zhang, S. Chen, X. Zhu, and Z. Yan, "Two hybrid end-effector posture-maintaining and AC avoidance schemes for redundant robot manipulators," IEEE Trans Ind. Informat., vol. 16, no. 2, pp. 754-763, Feb. 2020.

[22] L. E. Kavraki, P. Svestka, J.-C. Latombe, and M. H. Overmars, "Probabilistic roadmaps for path planning in high-dimensional configuration spaces," IEEE Trans. Robot. Autom., vol. 12, no. 4, pp. 566-580, Aug. 1996.

[23] S. M. Lavalle and J. J. Kuffner, "Rapidly-exploring random trees: Progress and prospects," in Algorithmic and Computational Robotics: New Directions. Boca Raton, FL, USA: CRC Press, 2000, pp. 293-308.

[24] M. Stilman, "Global manipulation planning in robot joint space with task constraints," IEEE Trans. Robot., vol. 26, no. 3, pp. 576-584, Jun. 2010.

[25] D. Berenson, S. Srinivasa, and J. Kuffner, "Task space regions: A framework for pose-constrained manipulation planning," Int. J. Robot. Res., vol. 30, no. 12, pp. 1435-1460, Oct. 2011, doi: 10. 1177/0278364910396389.

[26] Q. Qiu and Q. Cao, "Task constrained motion planning for 7-degree of freedom manipulators with parameterized submanifolds," Ind. Robot, Int. J., vol. 45, no. 3, pp. 363-370, May 2018, doi: 10.1108/IR-01-2018- 0004.

[27] J. Pan and D. Manocha, "Efficient configuration space construction and optimization for motion planning," Engineering, vol. 1, no. 1, pp. 046-057, Mar. 2015.

[28] J. Pan, X. Zhang, and D. Manocha, "Efficient penetration depth approximation using active learning," ACM Trans. Graph., vol. 32, no. 6, pp. 1-12, Nov. 2013.

[29] N. Das, N. Gupta, and M. Yip, "Fastron: An online learning-based model and active learning strategy for proxy collision detection," in Proc. 1st Annu. Conf. Robot Learn. (CoRL), Mountain View, CA, USA, Nov. 2017, pp. 496-504.

[30] J. Huh and D. D. Lee, "Learning high-dimensional mixture models for fast collision detection in rapidly-exploring random trees," in Proc. IEEE Int. Conf. Robot. Autom. (ICRA), May 2016, pp. 63-69.

[31] J. Pan and D. Manocha, "Fast probabilistic collision checking for sampling-based motion planning using locality-sensitive hashing," Int. J. Robot. Res., vol. 35, no. 12, pp. 1477-1496, 2016.

[32] I. Garcia, J. D. Martin-Guerrero, E. Soria-Olivas, R. J. Martinez, S. Rueda, and R. Magdalena, "A neural network approach for real-time collision detection," in Proc. IEEE Int. Conf. Syst., Man Cybern., vol. 5, Oct. 2002, pp. 1-5, doi: 10.1109/ICSMC.2002.1176371.

[33] S. S. Mirrazavi Salehian, N. Figueroa, and A. Billard, "A unified framework for coordinated multi-arm motion planning," Int. J. Robot. Res., vol. 37, no. 10, pp. 1205-1232, Sep. 2018, doi: 10. 1177/0278364918765952.

[34] J. Pan, S. Chitta, and D. Manocha, "FCL: A general purpose library for collision and proximity queries," in Proc. IEEE Int. Conf. Robot. Autom., May 2012, pp. 3859-3866.

[35] C. J. C. Burges, "A tutorial on support vector machines for pattern recognition," Data Mining Knowl. Discovery, vol. 2, no. 2, pp. 121-167, Jun. 1998.

[36] B. Scholkopf et al., "Comparing support vector machines with Gaussian kernels to radial basis function classifiers," IEEE Trans. Signal Process., vol. 45, no. 11, pp. 2758-2765, Nov. 1997.

[37] L. Chen, Y. Li, and K. Tang, "Variable-depth multi-pass tool path generation on mesh surfaces," Int. J. Adv. Manuf. Technol., vol. 95, nos. 5-8, pp. 2169-2183, Mar. 2018.

[38] S. Gottschalk, M. C. Lin, and D. Manocha, "OBBTree: A hierarchical structure for rapid interference detection," in Proc. 23rd Annu. Conf. Comput. Graph. Interact. Techn. (SIGGRAPH). New York, NY, USA: ACM, 1996, pp. 171-180, doi: 10.1145/237170.237244.

[39] C.-C. Chang and C.-J. Lin, "LIBSVM: A library for support vector machines," ACM Trans. Intell. Syst. Technol., vol. 2, no. 3, pp. 27:1-27:27, Apr. 2011. [Online]. Available: http://www.csie.ntu.edu.tw/~cjlin/libsvm

<!-- Meanless: Authorized licensed use limited to: TIANJIN UNIVERSITY. Downloaded on November 07,2024 at 06:17:45 UTC from IEEE Xplore. Restrictions apply.-->




<!-- Meanless: 1724 IEEE TRANSACTIONS ON AUTOMATION SCIENCE AND ENGINEERING, VOL. 17, NO. 4, OCTOBER 2020-->

<!-- Media -->

<img src="https://cdn.noedgeai.com/bo_d2slbg77aajc738sf8h0_13.jpg?x=135&y=169&w=228&h=285&r=0"/>

<!-- Media -->

Chengkai Dai is currently pursuing the Ph.D. degree with the Department of Sustainable Design Engineering, Delft University of Technology, Delft, The Netherlands.

He worked with the Department of Mechanical and Automation Engineering, The Chinese University of Hong Kong, Hong Kong. His research areas include robotics, geometry computing, and computational design.

<!-- Media -->

<img src="https://cdn.noedgeai.com/bo_d2slbg77aajc738sf8h0_13.jpg?x=139&y=516&w=221&h=278&r=0"/>

<!-- Media -->

Sylvain Lefebvre was the Principal Investigator of the ERC ShapeForge (StG) and IceXL (PoC) Projects from 2012 to 2017. He created and is the Lead Developer of the IceSL software for modeling for additive manufacturing. He is currently a Senior Researcher at Inria, Nancy, France, where he leads the MFX Team. His main research focus is to simplify content creation by automatically synthesizing highly detailed patterns, structures and shapes, with applications in computer graphics and additive manufacturing.

Dr. Lefebvre received the Eurographics Young Researcher Award in 2010.

<!-- Media -->

<img src="https://cdn.noedgeai.com/bo_d2slbg77aajc738sf8h0_13.jpg?x=137&y=902&w=226&h=280&r=0"/>

<!-- Media -->

Kai-Ming Yu received the B.Sc. (Eng.) degree in mechanical engineering from The University of Hong Kong, Hong Kong, in 1985, and the Ph.D. degree from the Department of Mechanical Engineering, The University of Hong Kong, in 1991.

He worked with the Research Centre, Mechanical Engineering Department, The Hong Kong University of Science and Technology, Hong Kong, until 1993. He is currently an Assistant Professor with the Industrial and Systems Engineering Department, The Hong Kong Polytechnic University, Hong Kong. His research interests include computer-aided design/computer-aided manufacturing (CAD/CAM), computer-aided engineering (CAE), and product data management (PDM), reverse engineering, and rapid prototyping technologies.

Dr. Yu is also a Senior Member of the Society of Manufacturing Engineers.

<!-- Media -->

<img src="https://cdn.noedgeai.com/bo_d2slbg77aajc738sf8h0_13.jpg?x=910&y=175&w=223&h=282&r=0"/>

<!-- Media -->

Jo M. P. Geraedts received the M.Sc. degree from the Eindhoven University of Technology, Eindhoven, The Netherlands, in 1976, and the Ph.D. degree from the University of Nijmegen, Nijmegen, The Netherlands, in 1983, all in physics.

From 1983 to 2017, he was with OcÃ©-van der Grinten, Venlo, The Netherlands. He is currently an Emeritus Professor of New Mechatronic Design with the Delft University of Technology (TU Delft), Delft, The Netherlands. His research areas include 3-D scanning, 3-D printing, and human-robot interaction.

<!-- Media -->

<img src="https://cdn.noedgeai.com/bo_d2slbg77aajc738sf8h0_13.jpg?x=909&y=902&w=226&h=283&r=0"/>

<!-- Media -->

Charlie C. L. Wang received the Ph.D. degree in mechanical engineering from The Hong Kong University of Science and Technology, Hong Kong, in 2002.

He was a tenured Professor and the Chair of Advanced Manufacturing with the Delft University of Technology (TU Delft), Delft, The Netherlands. He is currently a Professor of Mechanical and Automation Engineering and the Director of the Intelligent Design and Manufacturing Institute, The Chinese University of Hong Kong (CUHK), Hong Kong. His research areas include geometric computing, intelligent design, and advanced manufacturing.

Dr. Wang is also a fellow of the American Society of Mechanical Engineers (ASME) and The Hong Kong Institute of Engineers (HKIE).

<!-- Meanless: Authorized licensed use limited to: TIANJIN UNIVERSITY. Downloaded on November 07,2024 at 06:17:45 UTC from IEEE Xplore. Restrictions apply.-->

